
  // function G(
  //   uint32 a,
  //   uint32 b,
  //   uint32 c,
  //   uint32 d,
  //   uint32 m2i0,
  //   uint32 m2i1
  // ) public pure
  //   returns (uint32, uint32, uint32, uint32)
  // {
  //   assembly {

  //     a := add(a, add(b, m2i0))

  //     let x := xor(a, d)

  //     d := add(
  //       and(shr(16, x), 0xffff),
  //       shl(16, x)
  //     )

  //     c := add(c, d)

  //     x := xor(b, c)
  //     b := add(
  //       and(shr(12, x), 0xfffff),
  //       shl(20, x)
  //     )

  //     a := add(a, add(b, m2i1))

  //     x := xor(d, a)
  //     d := add(
  //       and(shr(8, x), 0xffffff),
  //       shl(24, x)
  //     )
    
  //     c := add(c, d)

  //     x := xor(b, c)
  //     b := add(
  //       and(shr(7, x), 0x1ffffff),
  //       shl(25, x)
  //     )
  //   }

  //   return (a, b, c, d);
  // }

  // function compress(
  //   uint32[8] memory h,     // chaining value
  //   uint32[16] memory m,    // message block
  //   uint64 t,               // counter (t0, t1) - t0 lower, t1 higher
  //   uint32 b,               // # of bytes in message block
  //   uint32 d                // flags
  // ) public pure
  //   returns (uint32[16] memory)
  // {
  //   uint32[16] memory v;

  //   // The rounds and permutations between rounds are unrolled.

  //   // round 1 (and state initialization)
  //   // columns
  //   (v[0], v[4], v[8], v[12]) = G(h[0], h[4], IV0, uint32(t), m[0], m[1]);
  //   (v[1], v[5], v[9], v[13]) = G(h[1], h[5], IV1, uint32(t >> 32), m[2], m[3]);
  //   (v[2], v[6], v[10], v[14]) = G(h[2], h[6], IV2, b, m[4], m[5]);
  //   (v[3], v[7], v[11], v[15]) = G(h[3], h[7], IV3, d, m[6], m[7]);
  //   // diagonals
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[8], m[9]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[10], m[11]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7], v[8], v[13], m[12], m[13]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[14], m[15]);

  //   // round 2
  //   (v[0], v[4],  v[8], v[12]) = G(v[0], v[4], v[8], v[12], m[2], m[6]);
  //   (v[1], v[5], v[9], v[13]) = G(v[1], v[5], v[9], v[13],  m[3], m[10]);
  //   (v[2], v[6], v[10], v[14]) = G(v[2], v[6], v[10], v[14],  m[7], m[0]);
  //   (v[3], v[7], v[11], v[15]) = G(v[3], v[7], v[11], v[15], m[4], m[13]);
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[1], m[11]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[12], m[5]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7],  v[8], v[13], m[9], m[14]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[15], m[8]);

  //   // round 3
  //   (v[0], v[4],  v[8], v[12]) = G(v[0], v[4], v[8], v[12], m[3], m[4]);
  //   (v[1], v[5], v[9], v[13]) = G(v[1], v[5], v[9], v[13],  m[10], m[12]);
  //   (v[2], v[6], v[10], v[14]) = G(v[2], v[6], v[10], v[14],  m[13], m[2]);
  //   (v[3], v[7], v[11], v[15]) = G(v[3], v[7], v[11], v[15], m[7], m[14]);
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[6], m[5]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[9], m[0]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7],  v[8], v[13], m[11], m[15]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[8], m[1]);

  //   // round 4
  //   (v[0], v[4],  v[8], v[12]) = G(v[0], v[4], v[8], v[12], m[10], m[7]);
  //   (v[1], v[5], v[9], v[13]) = G(v[1], v[5], v[9], v[13],  m[12], m[9]);
  //   (v[2], v[6], v[10], v[14]) = G(v[2], v[6], v[10], v[14],  m[14], m[3]);
  //   (v[3], v[7], v[11], v[15]) = G(v[3], v[7], v[11], v[15], m[13], m[15]);
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[4], m[0]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[11], m[2]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7],  v[8], v[13], m[5], m[8]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[1], m[6]);

  //   // round 5
  //   (v[0], v[4],  v[8], v[12]) = G(v[0], v[4], v[8], v[12], m[12], m[13]);
  //   (v[1], v[5], v[9], v[13]) = G(v[1], v[5], v[9], v[13],  m[9], m[11]);
  //   (v[2], v[6], v[10], v[14]) = G(v[2], v[6], v[10], v[14],  m[15], m[10]);
  //   (v[3], v[7], v[11], v[15]) = G(v[3], v[7], v[11], v[15], m[14], m[8]);
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[7], m[2]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[5], m[3]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7],  v[8], v[13], m[0], m[1]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[6], m[4]);

  //   // round 6
  //   (v[0], v[4],  v[8], v[12]) = G(v[0], v[4], v[8], v[12], m[9], m[14]);
  //   (v[1], v[5], v[9], v[13]) = G(v[1], v[5], v[9], v[13],  m[11], m[5]);
  //   (v[2], v[6], v[10], v[14]) = G(v[2], v[6], v[10], v[14],  m[8], m[12]);
  //   (v[3], v[7], v[11], v[15]) = G(v[3], v[7], v[11], v[15], m[15], m[1]);
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[13], m[3]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[0], m[10]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7],  v[8], v[13], m[2], m[6]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[4], m[7]);

  //   // round 7
  //   (v[0], v[4],  v[8], v[12]) = G(v[0], v[4], v[8], v[12], m[11], m[15]);
  //   (v[1], v[5], v[9], v[13]) = G(v[1], v[5], v[9], v[13],  m[5], m[0]);
  //   (v[2], v[6], v[10], v[14]) = G(v[2], v[6], v[10], v[14],  m[1], m[9]);
  //   (v[3], v[7], v[11], v[15]) = G(v[3], v[7], v[11], v[15], m[8], m[6]);
  //   (v[0], v[5], v[10], v[15]) = G(v[0], v[5], v[10], v[15], m[14], m[10]);
  //   (v[1], v[6], v[11], v[12]) = G(v[1], v[6], v[11], v[12], m[2], m[12]);
  //   (v[2], v[7], v[8], v[13]) = G(v[2], v[7],  v[8], v[13], m[3], m[4]);
  //   (v[3], v[4], v[9], v[14]) = G(v[3], v[4], v[9], v[14], m[7], m[13]);

  //   // finalization
  //   assembly {

  //     let i := v
  //     let j := add(v, 256)
  //     let cmp := j

  //     for {} lt(i, cmp) { i := add(i, 32)} {
  //       mstore(i, xor(mload(i), mload(j)))
  //       j := add(j, 32)
  //     }

  //     i := add(v, 256)
  //     j := h
  //     cmp := add(h, 256)

  //     for {} lt(j, cmp) { j := add(j, 32)} {
  //       mstore(i, xor(mload(i), mload(j)))
  //       i := add(i, 32)
  //     }
  //   }

  //   // v[0] ^= v[8];
  //   // v[1] ^= v[9]; v[2] ^= v[10]; v[3] ^= v[11];
  //   // v[4] ^= v[12]; v[5] ^= v[13]; v[6] ^= v[14]; v[7] ^= v[15];
  //   // v[8] ^= h[0]; v[9] ^= h[1]; v[10] ^= h[2]; v[11] ^= h[3];
  //   // v[12] ^= h[4]; v[13] ^= h[5]; v[14] ^= h[6]; v[15] ^= h[7];

  //   return v;
  // }